Name: Tony Dokanchi

| Date       |      Time       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Update |
|:-----------|:---------------:|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| April 5    |     9-10pm      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             I tried to write abstract, efficient code. |
| October 31 |  11:00-11:45pm  |                                                                                                                                              I discussed the merits of different algorithms and data structures with other students in class. We settled on precomputing a table where we hash all the keys and store the key-value pairs in a map of lists together with all other key-value pairs with the same hash. Then, when checking the values of specific keys, we can use the map to get a lookup for all vey-value pairs with the same hash in constant time, then simply search that greatly reduced list. |
| October 31 |   6:00-6:30pm   |                                                                                                                                                                                                                                                                                                                                                                                                       I coded the above algorithm. I used a Node class to store key-value pairs and a CollisionSet class to keep track of all the Nodes that have the same hash as the target key. Giving a bunch of different errors. |
| October 31 |   7:00-7:30pm   |                                                                                                                   The errors were largely a result of me just forgetting to initialize things and forgetting how arrays work. I fixed the bugs. The algorithm runs correctly, but slowly (I fail two of the test cases due to timing out, but if I increase the allotted time by modifying the tester file, I pass all four. **EDIT: Running the code on my PC at home lets me pass all four test cases easily. The code takes ~5.5 secs on my laptop and ~1.2 secs on my pc. It's a hardware issue. The code works.** |
| October 31 | 11:30pm-12:00am | I tested a bunch of different p values, discovering that the optimal value is around 100,000, not the values in the millions we were speculating about in class. Apparently, even on a decently strong PC, it's just faster to juggle less memory even if it means we have to linear search a couple things in the process. Our map ends up at 800KB, which is a very reasonable size. These changes are almost enough to make up for the fact that my laptop is a toaster and still can't get close to passing that last test case. But I'm completely destroying it on my PC with the exact same code, so I'm happy. |
| November 4 |    8-8:10pm     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Started coding the HashMap class based on discussions we had in class, then decided I didn't feel like it anymore. |
| November 5 |   10:15-11am    |                                                                                                                                                                                                                                                                                                                                                                                                                                                              I coded the HashMap class and finished doing the linear probing approach. Three test cases are working, one is looping infinitely. IDK what the issue is. |
| November 5 |   2:15-2:55pm   |                                                                                                                                   "Fixed" the issue with the linear probing algorithm. It passes all the test cases, but it's still slower than the hanging linked list thingie algorithm (chained lists? idk what it's called). The issue was around the hashing function, where it would create clusters (and thus runs) of consecutive non-null indices and slow the runtime. I solved this by choosing a radix and default table size such that (radix) is always a generator modulo (table size) * 2^k for any k. |


To add a new row to the table, click into a cell and then hit shift-enter.